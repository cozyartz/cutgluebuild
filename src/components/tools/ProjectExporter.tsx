import React, { useState } from 'react';
import toast from 'react-hot-toast';

interface ProjectExporterProps {
  svgData: string;
  projectTitle: string;
  metadata?: any;
}

interface ExportFormat {
  id: string;
  name: string;
  extension: string;
  description: string;
  icon: string;
}

const exportFormats: ExportFormat[] = [
  {
    id: 'svg',
    name: 'SVG Vector',
    extension: 'svg',
    description: 'Scalable vector graphics for laser cutters',
    icon: 'ruler'
  },
  {
    id: 'png',
    name: 'PNG Image',
    extension: 'png',
    description: 'High-resolution raster image',
    icon: '🖼️'
  },
  {
    id: 'pdf',
    name: 'PDF Document',
    extension: 'pdf',
    description: 'Portable document format',
    icon: '📄'
  },
  {
    id: 'dxf',
    name: 'DXF CAD',
    extension: 'dxf',
    description: 'AutoCAD drawing exchange format',
    icon: 'wrench'
  }
];

export default function ProjectExporter({ svgData, projectTitle, metadata }: ProjectExporterProps) {
  const [selectedFormat, setSelectedFormat] = useState('svg');
  const [isExporting, setIsExporting] = useState(false);
  const [exportSettings, setExportSettings] = useState({
    scale: 1,
    dpi: 300,
    includeMetadata: true
  });

  const exportProject = async (format: string) => {
    setIsExporting(true);
    
    try {
      const filename = `${projectTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}`;
      
      switch (format) {
        case 'svg':
          await exportSVG(filename);
          break;
        case 'png':
          await exportPNG(filename);
          break;
        case 'pdf':
          await exportPDF(filename);
          break;
        case 'dxf':
          await exportDXF(filename);
          break;
        default:
          throw new Error('Unsupported format');
      }
      
      toast.success(`Exported as ${format.toUpperCase()}`);
    } catch (error) {
      console.error('Export error:', error);
      toast.error('Failed to export project');
    } finally {
      setIsExporting(false);
    }
  };

  const exportSVG = async (filename: string) => {
    let svgContent = svgData;
    
    if (exportSettings.includeMetadata && metadata) {
      // Add metadata as comments
      const metadataComment = `<!-- Generated by CutGlueBuild
Project: ${projectTitle}
Created: ${new Date().toISOString()}
Settings: ${JSON.stringify(metadata)}
-->`;
      svgContent = svgContent.replace('<svg', `${metadataComment}\n<svg`);
    }
    
    const blob = new Blob([svgContent], { type: 'image/svg+xml' });
    downloadBlob(blob, `${filename}.svg`);
  };

  const exportPNG = async (filename: string) => {
    return new Promise<void>((resolve, reject) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = () => {
        const scale = exportSettings.scale;
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;
        
        if (ctx) {
          ctx.scale(scale, scale);
          ctx.drawImage(img, 0, 0);
          
          canvas.toBlob((blob) => {
            if (blob) {
              downloadBlob(blob, `${filename}.png`);
              resolve();
            } else {
              reject(new Error('Failed to create PNG'));
            }
          }, 'image/png');
        }
      };
      
      img.onerror = () => reject(new Error('Failed to load SVG'));
      img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
    });
  };

  const exportPDF = async (filename: string) => {
    // For PDF export, we'd typically use a library like jsPDF
    // This is a simplified version
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise<void>((resolve, reject) => {
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        
        if (ctx) {
          ctx.drawImage(img, 0, 0);
          
          // Convert to PDF (simplified - would use jsPDF in real implementation)
          canvas.toBlob((blob) => {
            if (blob) {
              downloadBlob(blob, `${filename}.pdf`);
              resolve();
            } else {
              reject(new Error('Failed to create PDF'));
            }
          }, 'image/png'); // Simplified - would be actual PDF
        }
      };
      
      img.onerror = () => reject(new Error('Failed to load SVG'));
      img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
    });
  };

  const exportDXF = async (filename: string) => {
    // DXF export would require SVG to DXF conversion
    // This is a placeholder implementation
    const dxfContent = `0
SECTION
2
HEADER
9
$ACADVER
1
AC1015
0
ENDSEC
0
SECTION
2
ENTITIES
${convertSVGToDXF(svgData)}
0
ENDSEC
0
EOF`;
    
    const blob = new Blob([dxfContent], { type: 'application/dxf' });
    downloadBlob(blob, `${filename}.dxf`);
  };

  const convertSVGToDXF = (svg: string): string => {
    // Simplified SVG to DXF conversion
    // In a real implementation, this would parse SVG elements and convert to DXF entities
    return `0
LINE
8
0
10
0.0
20
0.0
11
100.0
21
100.0
`;
  };

  const downloadBlob = (blob: Blob, filename: string) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <div className="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6">
      <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
        Export Project
      </h3>
      
      {/* Format Selection */}
      <div className="grid grid-cols-2 gap-3 mb-6">
        {exportFormats.map((format) => (
          <label
            key={format.id}
            className={`flex items-center p-3 border rounded-lg cursor-pointer transition-colors ${
              selectedFormat === format.id
                ? 'border-primary-500 bg-primary-50 dark:bg-primary-900/20'
                : 'border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700'
            }`}
          >
            <input
              type="radio"
              name="exportFormat"
              value={format.id}
              checked={selectedFormat === format.id}
              onChange={(e) => setSelectedFormat(e.target.value)}
              className="sr-only"
            />
            <div className="flex items-center space-x-3">
              <span className="text-2xl">{format.icon}</span>
              <div>
                <div className="font-medium text-gray-900 dark:text-white">
                  {format.name}
                </div>
                <div className="text-xs text-gray-600 dark:text-gray-400">
                  {format.description}
                </div>
              </div>
            </div>
          </label>
        ))}
      </div>

      {/* Export Settings */}
      <div className="space-y-4 mb-6">
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            Scale Factor
          </label>
          <input
            type="range"
            min="0.5"
            max="3"
            step="0.1"
            value={exportSettings.scale}
            onChange={(e) => setExportSettings(prev => ({ ...prev, scale: parseFloat(e.target.value) }))}
            className="w-full"
          />
          <div className="flex justify-between text-xs text-gray-500 dark:text-gray-500 mt-1">
            <span>0.5x</span>
            <span>{exportSettings.scale}x</span>
            <span>3x</span>
          </div>
        </div>

        {(selectedFormat === 'png' || selectedFormat === 'pdf') && (
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              DPI Quality
            </label>
            <select
              value={exportSettings.dpi}
              onChange={(e) => setExportSettings(prev => ({ ...prev, dpi: parseInt(e.target.value) }))}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
            >
              <option value={150}>150 DPI (Web)</option>
              <option value={300}>300 DPI (Print)</option>
              <option value={600}>600 DPI (High Quality)</option>
            </select>
          </div>
        )}

        <div className="flex items-center">
          <input
            type="checkbox"
            id="includeMetadata"
            checked={exportSettings.includeMetadata}
            onChange={(e) => setExportSettings(prev => ({ ...prev, includeMetadata: e.target.checked }))}
            className="mr-2"
          />
          <label htmlFor="includeMetadata" className="text-sm text-gray-700 dark:text-gray-300">
            Include project metadata
          </label>
        </div>
      </div>

      {/* Export Button */}
      <button
        onClick={() => exportProject(selectedFormat)}
        disabled={isExporting || !svgData}
        className="w-full btn btn-primary py-3 text-base font-medium disabled:opacity-50"
      >
        {isExporting ? (
          <>
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Exporting...
          </>
        ) : (
          <>
            <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
            </svg>
            Export as {selectedFormat.toUpperCase()}
          </>
        )}
      </button>
    </div>
  );
}